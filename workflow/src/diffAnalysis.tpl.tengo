// run annotation and DE analysis
self := import("@platforma-sdk/workflow-tengo:tpl")
smart := import("@platforma-sdk/workflow-tengo:smart")
ll := import("@platforma-sdk/workflow-tengo:ll")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
json := import("json")
pt := import("@platforma-sdk/workflow-tengo:pt")

topTablePfconvParamsLib := import(":topTablePfconvParams")
DEGPfconvParamsLib := import(":DEGPfconvParams")

mapToPValueData := func(map) {
	data := {}
	for key, value in map {
		data[json.encode([key])] = value
	}
	result := {
		keyLength: 1,
		data: data
	}
	return result
}

createJsonPColumnData := func(data) {
	return smart.createValueResource({ Name: "PColumnData/Json", Version: "1" }, data)
}

self.validateInputs({
	"__options__,closed": "",
	continueOrNot: "any",
	rawCounts: "any",
	csvCovariates: "any",
	numerators: "any",
	contrastFactor: "any",
	params: {
		"__options__,closed": "",
		"denominator,omitempty": "string",
		"log2FCThreshold,omitempty": "number",
		"pAdjThreshold,omitempty": "number",
		"defaultConvMem,omitempty": "string",
		"defaultConvCpu,omitempty": "number"
	},
	metaInputs: {
		"__options__,closed": "",
		"blockId,omitempty": "string"
	}
})

self.defineOutputs("degPF", "regDirPF", "topDegPF", "contrastExport")

self.body(func(inputs) {
	degPF := {}
	topDegPF := {}
	regDirPF := {}

	
	if string(inputs.continueOrNot.getData()) != "continue" {
		// If matrix is not full rank return empty objects
		return {
			degPF: degPF,
			regDirPF: regDirPF,
			topDegPF: topDegPF,
			contrastExport: {}
		}

	} else {
		// Proceed only if metadata matrix is full rank

		defaultConvMem := inputs.params.defaultConvMem
		defaultConvCpu := inputs.params.defaultConvCpu
		
		countsSpec := inputs.rawCounts.spec
		// @TODO: look for species only in axis when old Star version get obsolete
		species := countsSpec.domain["pl7.app/species"]
		// Last Star version holds species ID in axis domain
		if species == undefined {
			species = countsSpec.axesSpec[1].domain["pl7.app/species"]
		}

		// convert PColumns to csv
		csvCounts := xsv.exportFrame([inputs.rawCounts], "csv", { mem: defaultConvMem, cpu: defaultConvCpu })

		// Create PFrames for DEG, regulation direction and topTable
		wf := pt.workflow().cpu(1).mem("2GiB")
		dfsDeg := []
		dfsTopTable := []
		contrastMap := {}
		for numerator in inputs.numerators {
			numerator = string(numerator)
			contrastMap[numerator + " vs " + inputs.params.denominator] = numerator + " vs " + inputs.params.denominator
			diffExpression := exec.builder().
				software(assets.importSoftware("@platforma-open/milaboratories.run-deseq2-r.software:deseq2")).
				arg("-c").arg("rawCounts.csv").
				arg("-m").arg("covariates.csv").
				arg("-t").arg(inputs.contrastFactor.spec.annotations["pl7.app/label"]). // ??
				arg("-n").arg(numerator).
				arg("-d").arg(inputs.params.denominator).
				arg("-s").arg(species).
				arg("-o").arg("topTable.csv").
				arg("-f").arg(string(inputs.params.log2FCThreshold)).
				arg("-p").arg(string(inputs.params.pAdjThreshold)).
				addFile("rawCounts.csv", csvCounts).
				addFile("covariates.csv", inputs.csvCovariates).
				saveFile("topTable.csv").
				saveFile("DEG.csv").
				printErrStreamToStdout().			
				saveStdoutStream().
				cache(24 * 60 * 60 * 1000).
				run()

			dfsDeg += [wf.frame(diffExpression.getFile("DEG.csv"), {xsvType: "csv"})]
			dfsTopTable += [wf.frame(diffExpression.getFile("topTable.csv"), {xsvType: "csv"})]

		}

		// Concatenate all DEG and topTable files
		concatenatedDeg := pt.concat(dfsDeg)
		concatenatedDeg.save("concatenated_output_Deg.csv")
		concatenatedTopTable := pt.concat(dfsTopTable)
		concatenatedTopTable.save("concatenated_output_topTable.csv")
		ptablerResult := wf.run()

		topTableImportParams := topTablePfconvParamsLib.getColumns(copy(countsSpec),
																inputs.params.log2FCThreshold,
																inputs.params.pAdjThreshold)
		topTablePf := xsv.importFile(ptablerResult.getFile("concatenated_output_topTable.csv"), "csv", topTableImportParams, 
															// This changes output format from default to per column
															// So key will be column name and values spec and data
															{splitDataAndSpec: true, mem: defaultConvMem, cpu: defaultConvCpu})

		// Add DEG export with specific import params. Adding new csv output to script with only DEGs and logFC
		DEGImportParams := DEGPfconvParamsLib.getColumns(countsSpec, inputs.metaInputs.blockId, species)
		DEGPf := xsv.importFile(ptablerResult.getFile("concatenated_output_Deg.csv"), "csv", DEGImportParams, { mem: defaultConvMem, cpu: defaultConvCpu })

		trace := pSpec.makeTrace(countsSpec,
			{type: "milaboratories.differential-expression", importance: 30, 
			label: "DEG - Denominator: " + inputs.params.denominator + " (log2FC: " + inputs.params.log2FCThreshold + ", pAdj: " + inputs.params.pAdjThreshold + ")"}
		)

		degPFrameBuilder := pframes.pFrameBuilder()
		regDirPFrameBuilder := pframes.pFrameBuilder()
		topDegPFrameBuilder := pframes.pFrameBuilder()

		// Create contrast label Pcolumn
		contrastExport := {
			spec: {
				kind: "PColumn",
				name: "pl7.app/label",
				valueType: "String",
				annotations: {
					"pl7.app/label": "Contrast",
					"pl7.app/isLabel": "true"
				},
				axesSpec: [{
						name: "pl7.app/rna-seq/contrastGroup",
						type: "String",
						domain: {
							"pl7.app/blockId": inputs.metaInputs.blockId
						},
						annotations: {
							"pl7.app/label": "Contrast"
						}
				}]
			},
			data: createJsonPColumnData(json.encode(mapToPValueData(contrastMap)))
		}

		for columnName, value in topTablePf { 
			// avoid modifying the original spec
			columnData := value.data
			topDegPFrameBuilder.add(
				columnName,
				trace.inject(value.spec),
				columnData

			)
		}

		degPFrameBuilder.add(
			"Log2FC",
			trace.inject(DEGPf["log2foldchange.spec"]),
			DEGPf["log2foldchange.data"]
		)

		regDirPFrameBuilder.add(
			"Regulation Direction",
			trace.inject(DEGPf["regulationDirection.spec"]),
			DEGPf["regulationDirection.data"]
		)
		

		// Build the final PFrames
		degPF = degPFrameBuilder.build()
		topDegPF = topDegPFrameBuilder.build()
		regDirPF = regDirPFrameBuilder.build()

		return {
			degPF: degPF,
			regDirPF: regDirPF,
			topDegPF: pframes.exportFrame(topDegPF),
			contrastExport: contrastExport
		}
	} 
})
